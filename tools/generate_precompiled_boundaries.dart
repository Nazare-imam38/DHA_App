import 'dart:convert';
import 'dart:io';
import 'package:latlong2/latlong.dart';

/// Build script to generate pre-compiled boundary data from GeoJSON files
/// This eliminates runtime file parsing and provides instant access
void main() async {
  print('üîß Generating pre-compiled boundary data...');
  
  final outputDir = Directory('lib/core/services/generated');
  if (!outputDir.existsSync()) {
    outputDir.createSync(recursive: true);
  }
  
  final phases = [
    'Phase1', 'Phase2', 'Phase3', 'Phase4', 
    'Phase4_GV', 'Phase4_RVN', 'Phase4_RVS', 
    'Phase5', 'Phase6', 'Phase7'
  ];
  
  final phaseColors = {
    'Phase1': '0xFF4CAF50',
    'Phase2': '0xFF2196F3', 
    'Phase3': '0xFFFF9800',
    'Phase4': '0xFF9C27B0',
    'Phase4_GV': '0xFF9C27B0',
    'Phase4_RVN': '0xFF9C27B0',
    'Phase4_RVS': '0xFF9C27B0',
    'Phase5': '0xFFF44336',
    'Phase6': '0xFF00BCD4',
    'Phase7': '0xFF795548',
  };
  
  final boundaries = <String>[];
  
  for (final phase in phases) {
    print('üìÅ Processing $phase...');
    
    try {
      final file = File('assets/Boundaries/geojsons/$phase.geojson');
      if (!file.existsSync()) {
        print('‚ö†Ô∏è File not found: $phase.geojson');
        continue;
      }
      
      final jsonString = await file.readAsString();
      final jsonData = jsonDecode(jsonString);
      
      final boundary = _parseGeoJsonToDart(jsonData, phase, phaseColors[phase]!);
      boundaries.add(boundary);
      
      print('‚úÖ Processed $phase successfully');
    } catch (e) {
      print('‚ùå Error processing $phase: $e');
    }
  }
  
  // Generate the pre-compiled boundaries file
  await _generatePrecompiledFile(boundaries);
  
  print('üéâ Pre-compiled boundaries generated successfully!');
  print('üìä Generated ${boundaries.length} boundary phases');
  print('‚ö° Boundaries will now load INSTANTLY with zero performance impact');
}

/// Parse GeoJSON and convert to optimized Dart code
String _parseGeoJsonToDart(Map<String, dynamic> geoJson, String phaseName, String colorHex) {
  final polygons = <String>[];
  
  if (geoJson['type'] == 'FeatureCollection') {
    final features = geoJson['features'] as List<dynamic>;
    
    for (final feature in features) {
      final geometry = feature['geometry'] as Map<String, dynamic>;
      final coordinates = geometry['coordinates'] as List<dynamic>;
      
      if (geometry['type'] == 'MultiPolygon') {
        for (final polygon in coordinates) {
          final polygonCoords = _parsePolygonCoordinates(polygon as List<dynamic>);
          if (polygonCoords.isNotEmpty) {
            polygons.add('[\n${polygonCoords.join(',\n')}\n]');
          }
        }
      } else if (geometry['type'] == 'Polygon') {
        final polygonCoords = _parsePolygonCoordinates(coordinates);
        if (polygonCoords.isNotEmpty) {
          polygons.add('[\n${polygonCoords.join(',\n')}\n]');
        }
      }
    }
  }
  
  if (polygons.isEmpty) {
    return '';
  }
  
  return '''
    BoundaryPolygon(
      phaseName: '$phaseName',
      polygons: [
        ${polygons.join(',\n        ')}
      ],
      color: const Color($colorHex),
      icon: Icons.home_work,
    )''';
}

/// Parse polygon coordinates to LatLng objects
List<String> _parsePolygonCoordinates(List<dynamic> coordinates) {
  final points = <String>[];
  
  if (coordinates.isNotEmpty) {
    final firstRing = coordinates[0] as List<dynamic>;
    
    for (final point in firstRing) {
      if (point is List && point.length >= 2) {
        final lng = point[0] as double;
        final lat = point[1] as double;
        points.add('LatLng($lat, $lng)');
      }
    }
  }
  
  return points;
}

/// Generate the pre-compiled boundaries file
Future<void> _generatePrecompiledFile(List<String> boundaries) async {
  final content = '''// GENERATED FILE - DO NOT EDIT MANUALLY
// This file is auto-generated by tools/generate_precompiled_boundaries.dart
// Run 'dart run tools/generate_precompiled_boundaries.dart' to regenerate

import 'package:flutter/material.dart';
import 'package:latlong2/latlong.dart';
import '../unified_memory_cache.dart';

/// Pre-compiled boundary data for INSTANT loading
/// No file I/O, no JSON parsing, no performance impact
class PrecompiledBoundaries {
  /// Get all boundaries instantly - ZERO performance impact
  static List<BoundaryPolygon> getBoundariesInstantly() {
    return _boundaries;
  }
  
  /// Pre-compiled boundary data - optimized for instant access
  static final List<BoundaryPolygon> _boundaries = [
${boundaries.join(',\n')}
  ];
  
  /// Check if boundaries are loaded (always true for pre-compiled)
  static bool get isLoaded => true;
  
  /// Get boundary count
  static int get boundaryCount => _boundaries.length;
  
  /// Get loading status
  static Map<String, dynamic> getLoadingStatus() {
    return {
      'is_loaded': true,
      'is_loading': false,
      'boundary_count': _boundaries.length,
      'data_source': 'Pre-compiled (INSTANT)',
      'performance': 'ZERO_IMPACT',
    };
  }
}''';

  final file = File('lib/core/services/generated/precompiled_boundaries.dart');
  await file.writeAsString(content);
  
  print('üìÑ Generated: lib/core/services/generated/precompiled_boundaries.dart');
}
